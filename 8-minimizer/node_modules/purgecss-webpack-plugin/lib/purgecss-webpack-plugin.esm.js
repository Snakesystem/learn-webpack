import*as t from"fs";import*as s from"path";import{PurgeCSS as o,defaultOptions as e}from"purgecss";import{sources as i}from"webpack";const n=[".css",".scss",".styl",".sass",".less"],r="PurgeCSS";function c(t,s,o,i,n){const r={...e,...t,content:s,css:[{raw:o.source().toString()}]};return"function"==typeof r.safelist&&(r.safelist=r.safelist()),"function"==typeof r.blocklist&&(r.blocklist=r.blocklist()),{content:r.content,css:r.css,defaultExtractor:r.defaultExtractor,extractors:r.extractors,fontFace:r.fontFace,keyframes:r.keyframes,output:r.output,rejected:r.rejected,variables:r.variables,safelist:r.safelist,blocklist:r.blocklist,sourceMap:!!n&&{inline:!1,to:i}}}function a(t,s,o,e){if(!e||!o.sourceMap)return new i.RawSource(o.css);const{source:n,map:r}=s.sourceAndMap();return new i.SourceMapSource(o.css,t,o.sourceMap,n.toString(),r,!1)}class PurgeCSSPlugin{constructor(t){this.purgedStats={},this.options=t}apply(t){t.hooks.compilation.tap(r,this.initializePlugin.bind(this))}initializePlugin(o){o.hooks.additionalAssets.tapPromise(r,(async()=>{let e;try{const t=s.resolve(process.cwd(),"purgecss.config.js");e=await import(t)}catch{}this.options={...e||{},...this.options};const i="function"==typeof this.options.paths?this.options.paths():this.options.paths;return i.forEach((s=>{if(!t.existsSync(s))throw new Error(`Path ${s} does not exist.`)})),this.runPluginHook(o,i)}))}async runPluginHook(t,e){const i=Object.entries(t.assets).filter((([t])=>function(t,o){const e=s.extname((i=t).includes("?")?i.split("?").slice(0,-1).join(""):i);var i;return o.includes(e)}(t,[".css"])));for(const s of t.chunks){const r=i.filter((([t])=>!(this.options.only&&!this.options.only.some((s=>t.includes(s))))&&s.files.has(t)));for(const[s,i]of r){const r=e.filter((t=>!n.some((s=>t.endsWith(s))))),l=!!t.compiler.options.devtool,u=c(this.options,r,i,s,l),p=(await(new o).purge(u))[0];p.rejected&&(this.purgedStats[s]=p.rejected),t.updateAsset(s,a(s,i,p,l))}}}}export{PurgeCSSPlugin};
